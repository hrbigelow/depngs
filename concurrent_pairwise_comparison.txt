Here is described the algorithm for computing pairwise locus
composition distance comparisons.

The input consists of S pileup files, each one representing a sample
's'.  Another file, the 'comparison file' lists pairs of s_i, s_j to
be compared.  The algorithm will open S filehandles, and parse lines
together until the input is consumed.  Each comparison will involve:

1.  Sampling the posterior (either through MH or specified points) at
the same locus for both samples.

2.  Computing the 1D distribution of distance between the two
posterior samplings. 

a) In the case of MH, this will to compute euclidean distance for each
pair in a random subset of pairs of sample points, one from each
sample.
        
b) In the case of specified points, will be the cartesian product of
all points attaining above-threshold posterior value, and the CDF cut
points will be computed on the set of weighted points.

The output will be a set of quantiles on this 1D distribution,
representing error bars on the distance.


Details:


Initialization:
S filehandles
S line vectors
S current iterators CI (each represents the first position that has not yet been processed)
S bounding iterators BI (each represents the upper bound.  these may not be necessary)

Loop

For each s, if BI_s == CI_s, read in another chunk on FH_s and parse
into lines.  Suitably truncate/append line vector and set BI_s and CI_s accordingly.

Intuition: For a sample with very low coverage, a chunk of 10,000
lines, say, will span a larger fraction of the genome because lots of
loci will be absent from the pileup file in between every line.  In
this case, the BI_s will not advance very often, because the genomic
position of the line it points to will frequently be greater than its
peers.  So, it will remain near the beginning of the line vector,
while the others advance.  Because of this, such a sample will not
need to be refreshed very often.

Now that all BI_s and CI_s are set correctly, initialize the threaded
worker loop.

Worker loop initialization:

1.  Find the sample whose last line has the least genomic position.
2.  Using this sample's line vector, create T (number of threads) contiguous sub-ranges
3.  Initialize each of the T workers with one of these ranges.

Single worker initialization:
S current iterators, each pointing to the next locus in sample s to process
B, E, the range of input to work on
SG, the 'guide' iterator pointing inside the [B, E) range
M, the 'global current' iterator, pointing to one of the S current iterators.
   M represents the current iterator with the lowest genomic position.
OD  iterator pointing to the start of the output distances
OC  iterator pointing to the start of the output compositions

is_next Boolean flags assocated with each current iterator, set to 'true' if
its genomic position matches that of M, false otherwise.

S Locus objects, each initialized from the S current iterators
S Samplings of the posterior, generated from the Locus objects

Main loop:

For each sample pair P in the sample pairs (defined by the comparison
    file):

1.  Locate the posterior sampling data for each of the two samples in
    the pair, corresponding to genomic position represented by M.  If
    is_next is true, use the sampling.  If false, use the global NULL
    sampling.

2.  Compute the distance distribution, then store the desired
    quantiles of this distribution in the output structure.

End loop

For each sample in S

1.  If is_next, write out desired quantiles of marginals of sample
points.  (Or the NULL marginals, which would be pre-computed)

2.  Delete the sample points structure and the Locus structure
3.  Advance the current iterator
4.  Create a new Locus, and new posterior sample points

Initialize M

For each sample in S
1.  set is_next if cur_s's genomic position is the same as M's genomic position



The worker cannot know if it is at the end of the range for a
particular sample, unless it has a sentinel iterator for that sample.
The reason is that the particular set of missing loci is unknown for a
given sample.

So, given that each 'cur' iterator will more or less advance at its
own pace, and reach the end in some unspecified order, is there any
way that we can know, efficiently, when all of them are at the end?

There should be one sample having the highest position as its last
locus.  Then, when this iterator reaches the end, we know that all
iterators must have reached the end.



Details/Other concerns:

Need a few different modules to this:

1.  The worker module




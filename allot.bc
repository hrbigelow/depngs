define mcn(m, n) { 
    auto r, s, t, ti;
    r = 1;
    s = 1;
    ti = 1;
    for (t = m; t > m - n; --t) { r *= t; s *= ti++; }; 
    return r / s;
}

/* compute log of the binomial with m trials, n successes, and
   probability of success p */
define logbinom(m, n, p) { 
    auto lc, ls, lf, z, r;
    z = scale;
    scale = 100;
    lc = l(mcn(m, n));
    ls = n * l(p);
    lf = (m - n) * l(1 - p);
    scale = z;
    return (lc + ls + lf) / 1;
}


/* compute the probability of converting a set of 'total' chips, from
   a configuration having bh blue showing to a configuration having bv
   blue showing, and assuming that overlap chips in common between the
   bh and the bv.  */
define log_basecall_component(total, n_bhid, n_bvis, olap, p) {
    auto log_prob, n_br_flip, n_rb_flip, n_flip, n_stay;
    n_br_flip = n_bhid - olap;
    n_rb_flip = n_bvis - olap;
    n_flip = n_br_flip + n_rb_flip;
    n_stay = total - n_flip;
    n_rvis = total - n_bvis;
    /* print \ */
    /*     "mcn(", n_rvis, ", ", n_br_flip, ") ", \ */
    /*     "* mcn(", n_bvis, ", ", n_rb_flip, ") ", \ */
    /*     "* ", p, "^", n_flip, " ", \ */
    /*     "* ", 1-p, "^", n_stay, "\n"; */
    log_prob =                      \
        l(mcn(n_rvis, n_br_flip))   \
        + l(mcn(n_bvis, n_rb_flip)) \
        + n_flip * l(p) \
        + n_stay * l(1-p);
    return log_prob;
}



/* should be normalized over n from 0 to m */
define binom(m, n, p) {
    return e(logbinom(m, n, p));
}



define max(a, b) { if (a < b) return b else return a }
define min(a, b) { if (a < b) return a else return b }

define flip(m, n1, n2, p) {
    auto i, nmin, flr1, flr2, s, fac, z;
    z = scale;
    scale = 100;
    flr1 = max(n2-n1,0);
    flr2 = max(n1-n2,0);
    nmin = min(m-n1-flr1, n1-flr2);
    s = 0;
    for (i = 0; i <= nmin; ++i) {
        /* print "logbinom(", m-n1, ", ", flr1+i, ", ", p, "), logbinom(", n1, ", ", flr2+i, ", ", p, ")\n"; */
        fac = logbinom(m-n1,flr1+i,p) + logbinom(n1,flr2+i,p);
        s += e(fac);
    }
    scale = z;
    return s / 1;
}


define allot(t, b) {
    auto i, s;
    s = 0;
    if (b == 1 || t == 0) { return 1; }
    for (i = 1; i <= b && i <= t; ++i) {
        s += allot(t - i, i) * mcn(b, i);
    }
    return s;
}
